package com.zygateley.compiler;

import java.io.*;
import java.util.*;

public class PythonTranslator {
	private Node syntaxTree;
	private StringBuilder stringBuilder;
	private FileWriter fileWriter;
	private int currentIndent;
	private boolean newLine;
	
	public PythonTranslator(Node syntaxTree) {
		this.syntaxTree = syntaxTree;
		this.stringBuilder = new StringBuilder();
	}
	public PythonTranslator(Node syntaxTree, FileWriter fileWriter) {
		this.syntaxTree = syntaxTree;
		this.fileWriter = fileWriter;
	}
	
	/**
	 * "Compile" code into Python 
	 * @return compiled code
	 */
	public String toPython() throws IOException {
		// Restart string builder if translator has already been called
		currentIndent = 0;
		if (stringBuilder != null) {
			stringBuilder.setLength(0);
		}
		else if (fileWriter != null) {
			// Do not have access to file path from fileWriter
			// Cannot refresh stream
		}
		
		// Header
		println("# Python code automatically generated by ");
		println("# com.zygateley.compiler.Translator::toPython");
		println();
		
		// Crawl syntax tree
		translateNode(syntaxTree);
		
		// Return result
		if (stringBuilder != null) {
			return stringBuilder.toString();
		}
		else {
			return fileWriter.toString();
		}
	}
	private void crawlChildrenAndTranslate(Node parent) throws IOException {
		if (parent == null) return;
		for (Node child : parent) {
			if (child != null) translateNode(child);
		}
	}
	private void translateNode(Node nodeAsBasic) throws IOException {
		if (nodeAsBasic == null) return;
		Node node = (Node) nodeAsBasic;
		
		int childCount = node.getChildCount();
		
		if (node.isNegated()) {
			print("(-");
		}
		
		// Try NonTerminal
		NonTerminal rule = node.getRule();
		Node firstChild = (Node) node.getFirstChild();
		if (rule != null) {
			switch (rule) {
			case _FUNCDEF_:
				print("def ");
				Node nextChild = firstChild;
				for (int i = 0; i < childCount - 1; i++) {
					translateNode(nextChild);
					nextChild = (Node) nextChild.getNextSibling();
				}
				println(":");
				currentIndent++;
				translateNode(nextChild);
				currentIndent--;
				break;
			case _IF_:
				println();
				print("if ");
				// Expression
				translateNode(node.getChild(2));
				println(":");
				currentIndent++;
				translateNode(node.getChild(4));
				currentIndent--;
				println();
				break;
			case _ELSEIF_:
				// Can go into pattern starting with terminal elseif 
				// or into pattern starting with terminal else
				// or may be empty
				if (firstChild.getToken() == Terminal.ELSEIF) {
					// Else if condition exists
					println();
					currentIndent--;
					print("elif");
					translateNode(node.getChild(2));
					println(":");
					currentIndent++;
					translateNode(node.getChild(4));
				}
				else if (firstChild.getToken() == Terminal.ELSE) {
					// Else condition exists
					println();
					currentIndent--;
					println("else:");
					currentIndent++;
					translateNode(node.getChild(1));
				}
				break;
			case _BLOCK_:
				// Python does not contain if-then scopes, so just process normally
				crawlChildrenAndTranslate(node);
				break;
			case _STMT_:
				crawlChildrenAndTranslate(node);
				println();
				break;
			case _ECHO_:
				// Expressions all enclosed in parentheses,
				// So no need to place them here
				print("print (");
				crawlChildrenAndTranslate(node);
				println(")");
				break;
			case _INPUT_:
				translateNode(node.getChild(1));
				print(" = input() ");
				break;
			case __BINARY__:
				print("(");
				translateNode(node.getChild(0));
				print(" ");
				printTerminal(node.getToken());
				print(" ");
				translateNode(node.getChild(1));
				print(")");
				break;
			case __UNARY__:
				printTerminal(node.getToken());
				translateNode(node.getChild(0));
				break;
			default:
				crawlChildrenAndTranslate(node);
				break;
			}
		}
		// Try Terminal
		else {
			Terminal t = node.getToken();
			String value;
			switch (t) {
			case INT:
				value = node.getValue();
				print(value);
				break;
			case STRING:
				print(node.getSymbol().getValue());
				break;
			case COMMENT:
				value = "#" + node.getValue().substring(2);
				print(value);
				break;
			case VAR:
				print(node.getSymbol().getName());
				break;
			default:
				printTerminal(t);
				break;
			}
		}
		
		if (node.isNegated()) {
			print(")");
		}
		
		return;
	}
	
	private void print(String output) throws IOException {
		if (newLine) {
			String indent = "    ".repeat(currentIndent);
			if (stringBuilder != null) {
				stringBuilder.append(indent);
			}
			if (fileWriter != null) {
				fileWriter.append(indent);
			}
			newLine = false;
		}
		if (stringBuilder != null) {
			stringBuilder.append(output);
		}
		if (fileWriter != null) {
			fileWriter.append(output);
		}
	}
	private void printTerminal(Terminal t) throws IOException {
		// Try Terminal
		switch (t) {
		case FUNCTION:
		case ECHO:
		case CURLY_OPEN:
		case CURLY_CLOSE:
		case SEMICOLON:
		case EMPTY:
		case EOF:
			// These handled by their wrapping NonTerminals
			break;
		case TRUE:
			print("True");
			break;
		case FALSE:
			print("False");
			break;
		case EQ:
			print(" =");
			break;
		case NEQ:
			print(" ~=");
			break;
		case AND:
			print(" and");
			break;
		case OR:
			print(" or");
			break;
		case NOT:
			print("~");
			break;
		case PAREN_OPEN:
			print(" (");
			break;
		case PAREN_CLOSE:
			print(") ");
			break;
		case COMMA:
			print(", ");
			break;
		default:
			print(t.exactString);
			break;
		}
	}
	private void println(String output) throws IOException {
		print(output);
		print("\r\n");
		newLine = true;
	}
	private void println() throws IOException {
		println("");
	}
}
