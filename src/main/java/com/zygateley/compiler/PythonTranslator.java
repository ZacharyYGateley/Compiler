package com.zygateley.compiler;

import java.io.*;

public class PythonTranslator {
	private Node syntaxTree;
	private StringBuilder stringBuilder;
	private FileWriter fileWriter;
	private int currentIndent;
	private boolean newLine;
	
	public PythonTranslator(Node syntaxTree) {
		this.syntaxTree = syntaxTree;
		this.stringBuilder = new StringBuilder();
	}
	public PythonTranslator(Node syntaxTree, FileWriter fileWriter) {
		this.syntaxTree = syntaxTree;
		this.fileWriter = fileWriter;
	}
	
	/**
	 * "Compile" code into Python 
	 * @return compiled code
	 */
	public String toPython() throws IOException {
		// Restart string builder if translator has already been called
		currentIndent = 0;
		if (stringBuilder != null) {
			stringBuilder.setLength(0);
		}
		else if (fileWriter != null) {
			// Do not have access to file path from fileWriter
			// Cannot refresh stream
		}
		
		// Header
		println("# Python code automatically generated by ");
		println("# com.zygateley.compiler.PythonTranslator::toPython");
		println();
		
		// Crawl syntax tree
		translateNode(syntaxTree);
		
		// Return result
		if (stringBuilder != null) {
			return stringBuilder.toString();
		}
		else {
			return fileWriter.toString();
		}
	}
	private void crawlChildrenAndTranslate(Node parent) throws IOException {
		if (parent == null) return;
		for (Node child : parent) {
			if (child != null) translateNode(child);
		}
	}
	private void translateNode(Node node) throws IOException {
		if (node == null) return;
		
		
		if (node.isNegated()) {
			print("(-");
		}
		
		// Try NonTerminal
		Element element = node.getElementType();
		Node firstChild = (Node) node.getFirstChild();
		Node nextChild;
		int childCount = node.getChildCount();
		if (element != null) {
			switch (element) {
			case FUNCDEF:
				println();
				// Function signature
				print("def ");
				// Function name
				translateNode(firstChild);
				print("(");
				// Function parameters
				nextChild = firstChild.getNextSibling();
				// All but last child are parameters
				printList(nextChild.getFirstChild(), nextChild.getChildCount());
				print(")");
				println(":");
				
				// Function body
				currentIndent++;
				translateNode(node.getLastChild());
				currentIndent--;
				println();
				break;
			case IF:
				print("if ");
				// Condition
				translateNode(firstChild);
				println(":");

				// Body
				currentIndent++;
				nextChild = firstChild.getNextSibling();
				translateNode(nextChild);
				currentIndent--;
				
				// else / else if
				nextChild = nextChild.getNextSibling();
				if (nextChild != null) {
					println();
					if (Element.IF.equals(nextChild.getElementType())) {
						print("el");
						translateNode(nextChild);
					}
					else {
						print("else:");
						println();
						currentIndent++;
						translateNode(nextChild);
						currentIndent--;
						println();
					}
				}
				break;
			case OUTPUT:
				print("print (");
				crawlChildrenAndTranslate(node);
				println(")");
				break;
			case INPUT:
				translateNode(firstChild);
				println(" = input()");
				break;
			case OPERATION:
				nextChild = firstChild.getNextSibling();
				if (nextChild == null) {
					// Unary
					printTerminal(node.getToken());
					translateNode(firstChild);
				}
				else {
					// Binary
					print("(");
					translateNode(firstChild);
					print(" ");
					printTerminal(node.getToken());
					print(" ");
					translateNode(nextChild);
					print(")");
				}
				break;
			case FUNCCALL:
				// Function name
				printValue(node);
				print("(");
				
				// Arguments
				// All children are arguments
				printList(firstChild, childCount);
				
				println(")");
				break;
			case VARDEF:
				printValue(node);
				print(" = ");
				translateNode(node.getFirstChild());
				println();
				break;
			case VAROUT:
			case LITERAL:
				printValue(node);
				break;
			default:
				crawlChildrenAndTranslate(node);
				break;
			}
		}
		
		if (node.isNegated()) {
			print(")");
		}
		
		return;
	}
	
	private void printList(Node nextChild, int limit) throws IOException {
		int count = 0;
		boolean isFirstArgument = true;
		while (nextChild != null && count++ < limit) {
			if (!isFirstArgument) {
				print(", ");
			}
			isFirstArgument = false;
			translateNode(nextChild);
			nextChild = nextChild.getNextSibling();
		}
	}
	
	private void print(String output) throws IOException {
		if (newLine) {
			String indent = "    ".repeat(currentIndent);
			if (stringBuilder != null) {
				stringBuilder.append(indent);
			}
			if (fileWriter != null) {
				fileWriter.append(indent);
			}
			newLine = false;
		}
		if (stringBuilder != null) {
			stringBuilder.append(output);
		}
		if (fileWriter != null) {
			fileWriter.append(output);
		}
	}
	private void printValue(Node node) throws IOException {
		Terminal t = node.getToken();
		String value;
		switch (t) {
		case INT:
			value = node.getValue();
			print(value);
			break;
		case STRING:
			print(node.getSymbol().getValue());
			break;
		case COMMENT:
			value = "#" + node.getValue().substring(2);
			print(value);
			break;
		case VAR:
			print(node.getSymbol().getName());
			break;
		default:
			printTerminal(t);
			break;
		}
	}
	private void printTerminal(Terminal t) throws IOException {
		// Try Terminal
		switch (t) {
		case FUNCTION:
		case ECHO:
		case CURLY_OPEN:
		case CURLY_CLOSE:
		case SEMICOLON:
		case EMPTY:
		case EOF:
			// These handled by their wrapping NonTerminals
			break;
		case TRUE:
			print("True");
			break;
		case FALSE:
			print("False");
			break;
		case EQ:
			print(" =");
			break;
		case NEQ:
			print(" ~=");
			break;
		case AND:
			print(" and");
			break;
		case OR:
			print(" or");
			break;
		case NOT:
			print("~");
			break;
		case SLASH:
			// For the moment, it is integer division
			print("//");
			break;
		case PAREN_OPEN:
			print(" (");
			break;
		case PAREN_CLOSE:
			print(") ");
			break;
		case COMMA:
			print(", ");
			break;
		default:
			print(t.exactString);
			break;
		}
	}
	private void println(String output) throws IOException {
		print(output);
		print("\r\n");
		newLine = true;
	}
	private void println() throws IOException {
		println("");
	}
}
